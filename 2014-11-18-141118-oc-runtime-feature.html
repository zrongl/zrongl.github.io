<!DOCTYPE html>





<html class="theme-next mist use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="generator" content="Hexo 3.9.0">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.3.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.3.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.3.0">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.3.0',
    sidebar: {"position":"right","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    save_scroll: false,
    copycode: {"enable":false,"show_result":false,"style":null},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    }
  };
</script>

  <meta name="description" content="OC的动态运行时是OC语言不可忽视的一个非常重要的特性。理解运行时的特性可以加深你对Object-C语言本身的理解并能够了解你的应用是如何运行的。所以作为 Mac或iPhone的开发者,无论你的水平阅历如何都会从对OC动态运行时特性的理解中获取一些有益的东西。">
<meta property="og:type" content="article">
<meta property="og:title" content="OC运行时特性(原创)">
<meta property="og:url" content="http://zrongl.github.io/2014-11-18-141118-oc-runtime-feature.html">
<meta property="og:site_name" content="善恶众相">
<meta property="og:description" content="OC的动态运行时是OC语言不可忽视的一个非常重要的特性。理解运行时的特性可以加深你对Object-C语言本身的理解并能够了解你的应用是如何运行的。所以作为 Mac或iPhone的开发者,无论你的水平阅历如何都会从对OC动态运行时特性的理解中获取一些有益的东西。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://zrongl.github.io/2014-11-18-141118-oc-runtime-feature/141118-oc-runtime-feature-00.png">
<meta property="og:image" content="http://zrongl.github.io/2014-11-18-141118-oc-runtime-feature/141118-oc-runtime-feature-01.png">
<meta property="og:updated_time" content="2019-08-07T07:24:05.260Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="OC运行时特性(原创)">
<meta name="twitter:description" content="OC的动态运行时是OC语言不可忽视的一个非常重要的特性。理解运行时的特性可以加深你对Object-C语言本身的理解并能够了解你的应用是如何运行的。所以作为 Mac或iPhone的开发者,无论你的水平阅历如何都会从对OC动态运行时特性的理解中获取一些有益的东西。">
<meta name="twitter:image" content="http://zrongl.github.io/2014-11-18-141118-oc-runtime-feature/141118-oc-runtime-feature-00.png">
  <link rel="canonical" href="http://zrongl.github.io/2014-11-18-141118-oc-runtime-feature">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>OC运行时特性(原创) | 善恶众相</title>
  








  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  <div class="container sidebar-position-right">
    <div class="headband"></div>

<a href="https://github.com/zrongl" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">善恶众相</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
  </ul>

    

</nav>
</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content page-post-detail">
            

  <div id="posts" class="posts-expand">
    

  <article class="post post-type-categories" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zrongl.github.io/2014-11-18-141118-oc-runtime-feature.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zrongl">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="善恶众相">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">OC运行时特性(原创)

            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2014-11-18 00:00:00" itemprop="dateCreated datePublished" datetime="2014-11-18T00:00:00+08:00">2014-11-18</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-08-07 15:24:05" itemprop="dateModified" datetime="2019-08-07T15:24:05+08:00">2019-08-07</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            <div class="post-description">OC的动态运行时是OC语言不可忽视的一个非常重要的特性。理解运行时的特性可以加深你对Object-C语言本身的理解并能够了解你的应用是如何运行的。所以作为 Mac或iPhone的开发者,无论你的水平阅历如何都会从对OC动态运行时特性的理解中获取一些有益的东西。</div>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="C语言编译链接过程"><a href="#C语言编译链接过程" class="headerlink" title="C语言编译链接过程"></a>C语言编译链接过程</h3><p>我们以以下代码为例，看看该源代码是如何最终生成可执行文件的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJC  <span class="meta-string">"UIWindow"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> *<span class="title">Class</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> *<span class="title">id</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">id</span> <span class="params">(*IMP)</span><span class="params">(id, <span class="keyword">const</span> <span class="keyword">char</span>*, ...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_method</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *method_name;</span><br><span class="line">    <span class="keyword">char</span> *method_types;</span><br><span class="line">    IMP method_imp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_method_list</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_method_list</span> *<span class="title">obsolete</span>;</span></span><br><span class="line">    <span class="keyword">int</span> method_count;</span><br><span class="line">    <span class="comment">/* variable length structure */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_method</span> <span class="title">method_list</span>[1];</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> &#123;</span></span><br><span class="line">    Class isa;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_method_list</span> **<span class="title">methodLists</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">id <span class="title">objc_msgSend</span><span class="params">(id self, <span class="keyword">const</span> <span class="keyword">char</span> *sel)</span></span>;</span><br><span class="line"><span class="function">id <span class="title">objc_getClass</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// insert code here...</span></span><br><span class="line">    Class cls = objc_msgSend(objc_getClass(OBJC), <span class="string">"alloc"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello, World!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">id <span class="title">objc_msgSend</span><span class="params">(id self, <span class="keyword">const</span> <span class="keyword">char</span> *sel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    // 区分类方法还是对象方法</span></span><br><span class="line"><span class="comment">    if (sel is class method) &#123;</span></span><br><span class="line"><span class="comment">        // 元类方法查找流程 ???</span></span><br><span class="line"><span class="comment">    &#125;else if (sel is object method)&#123;</span></span><br><span class="line"><span class="comment">        // 类方法查找流程即 消息分发</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">id <span class="title">objc_getClass</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// objc_auto.m =&gt; objc_registerClassPair</span></span><br><span class="line">    <span class="comment">// 用到某个类方法之前就已经在内存中创建了该类对象</span></span><br><span class="line">    <span class="comment">// 获取NSMapTable结构，不存在就去创建(应该不会存在该情况)，存在直接查找</span></span><br><span class="line">    <span class="comment">// 查找跟name匹配的mappair-&gt;key 并返回对应的mappair-&gt;value</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>a. 预处理(Pre-Processing)</strong></p>
<p>gcc -E objc.c -o objc.i<br>执行结果生成了<em>objc.i</em> 文件，内容如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">……</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">sFliEX</span>;</span></span><br><span class="line"># <span class="number">120</span> <span class="string">"/Applications/Xcode6.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.9.sdk/usr/include/stdio.h"</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">sFliE</span> &#123;</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> *_p;</span><br><span class="line"> <span class="keyword">int</span> _r;</span><br><span class="line"> <span class="keyword">int</span> _w;</span><br><span class="line"> <span class="keyword">short</span> _flags;</span><br><span class="line"> <span class="keyword">short</span> _flie;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> __<span class="title">sbuf</span> _<span class="title">bf</span>;</span></span><br><span class="line"> <span class="keyword">int</span> _lbfsize;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">void</span> *_cookie;</span><br><span class="line"> <span class="keyword">int</span> (*_close)(<span class="keyword">void</span> *);</span><br><span class="line"> <span class="keyword">int</span> (*_read) (<span class="keyword">void</span> *, <span class="keyword">char</span> *, <span class="keyword">int</span>);</span><br><span class="line"> <span class="keyword">fpos_t</span> (*_seek) (<span class="keyword">void</span> *, <span class="keyword">fpos_t</span>, <span class="keyword">int</span>);</span><br><span class="line"> <span class="keyword">int</span> (*_write)(<span class="keyword">void</span> *, <span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line">……</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Class cls = objc_msgSend(objc_getClass(<span class="string">"UIWindow"</span>), <span class="string">"alloc"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello, World!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>我们发现，该过程其实是把<em>stdio.h</em> 文件中的内容插入到了<em>objc.i</em> 文件中，并且将用到宏<code>OBJC</code>的地方都替换成它对应的<code>NSObject</code>，所以该阶段主要处理#ifdef、 #include和#define等命令的语义。 </p>
<p><strong>b. 编译（Compliing）</strong></p>
<p>gcc -S objc.i -o objc.s<br>执行结果生成<em>objc.s</em>文件，内容如下：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">_main:                                  <span class="comment">## @main</span></span><br><span class="line">	.cfi_startproc</span><br><span class="line"><span class="comment">## BB#0:</span></span><br><span class="line">	pushq	%rbp</span><br><span class="line">Ltmp2:</span><br><span class="line">	.cfi_def_cfa_offset <span class="number">16</span></span><br><span class="line">Ltmp3:</span><br><span class="line">	.cfi_offset %rbp, -<span class="number">16</span></span><br><span class="line">	movq	%rsp, %rbp</span><br><span class="line">Ltmp4:</span><br><span class="line">	.cfi_def_cfa_register %rbp</span><br><span class="line">	subq	$32, %rsp</span><br><span class="line">	leaq	L<span class="number">_</span>.str(%rip), %rax</span><br><span class="line">	movl	$0, -<span class="number">4</span>(%rbp)</span><br><span class="line">	movl	%edi, -<span class="number">8</span>(%rbp)</span><br><span class="line">	movq	%rsi, -<span class="number">16</span>(%rbp)</span><br><span class="line">	movq	%rax, %rdi</span><br><span class="line">	callq	_objc_getClass</span><br><span class="line">	leaq	L<span class="number">_</span>.str1(%rip), %rsi</span><br><span class="line">	movq	%rax, %rdi</span><br><span class="line">	callq	_objc_msgSend</span><br><span class="line">	leaq	L<span class="number">_</span>.str2(%rip), %rdi</span><br><span class="line">	movq	%rax, -<span class="number">24</span>(%rbp)</span><br><span class="line">	movb	$0, %al</span><br><span class="line">	callq	_printf</span><br></pre></td></tr></table></figure>

<p>我们发现该阶段生成了汇编代码，但是在进行转换之前编译器会对代码规范性及语法做检查然后给我警告或错误，如果没有检测到错误那么就会继续生成汇编代码文件。 </p>
<p><strong>c. 汇编（Assembling）</strong></p>
<p>gcc -c objc.s -o objc.o<br>此时生成了可重定位目标文件（ELF文件结构）<em>objc.o</em>，该文件中包含了二进制代码和数据，可以在链接的时候与其他可重定位目标文件合并起来，创建一个可执行目标文件。 </p>
<p><strong>d. 链接（Linking）</strong></p>
<p>gcc objc.o -o objc<br>生成了可执行目标文件（ELF文件结构）<em>objc</em>，此文件包含的也是二进制代码和数据，它可以被直接拷贝到内存中去运行，我们可以通过<code>./objc</code>命令执行该文件(程序)。 </p>
<p>回过头来我们再看<em>objc.c</em> 中我们调用了<code>printf</code>函数，但是在预编译生成的<em>objc.i</em> 文件中，我们只找到了该函数的声明并没有定义，那该函数在哪里实现的呢？在默认情况下，这些系统级的调用的实现会被放到<em>libc.so.6</em> 的库文件中，链接要做的就是把该函数的实现链接到<em>libc.so.6</em> 的库中，这样在执行文件的时候就能够找到实现并完成程序的运行。 </p>
<blockquote>
<p>tips：函数库一般分为静态库和动态库两种。静态库是指编译链接时，把库文件的代码全部加入到可执行文件中，因此生成的文件比较大，但在运行时也就不再需要库文件了。其后缀名一般为<em>.a*。动态库与之相反，在编译链接时并没有把库文件的代码加入到可执行文件中，而是在程序执行时由运行时链接文件加载库，这样可以节省系统的开销。动态库一般后缀名为</em>.so<em>，如前面所述的*libc.so.6</em> 就是动态库。Gcc在编译时默认使用动态库。</p>
</blockquote>
<p>最后运行生成的可执行文件<em>objc</em> </p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./objc</span><br><span class="line"><span class="built_in">Hello,</span> World!</span><br></pre></td></tr></table></figure>

<h3 id="对象，类及元类的关系："><a href="#对象，类及元类的关系：" class="headerlink" title="对象，类及元类的关系："></a>对象，类及元类的关系：</h3><p>在C++中类是抽象的，不占用内存，而对象是由类初始化而来的，占有内存空间。<strong>但是OC中所谓的类其本质上只是对结构体</strong><br><code>typedef struct objc_class *Class;</code><br><strong>的封装，OC中没有C++中真正意义上的类，所有的对象、类或元类(个别除外)在运行时候都是占有内存的，它们最终都继承自同一个父类——NSObject。</strong> </p>
<img src="/2014-11-18-141118-oc-runtime-feature/141118-oc-runtime-feature-00.png" title="实例、对象、类的继承关系">

<p>根据C++中的经验，对象实例是由类创建并初始化而来的，实例对象可以调用在类中声明的方法，而在OC中出现了类方法，即类本身可以调用自己的类方法。延伸一下思考的话，在OC中我们可以把类也当成对象来看待，那么这些类方法又声明在哪里呢？ </p>
<figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> </span>&#123;</span><br><span class="line">    Class isa;</span><br><span class="line">    ……                  </span><br><span class="line">&#125; OBJC2_UNAVAliABLE;</span><br></pre></td></tr></table></figure>

<p>观察<code>struct objc_class</code>结构可以得知每一个类或对象中都有一个isa属性，对于对象而言isa指向（创建该对象）持有对象方法声明的类，对于类而言isa指向（创建该类）持有类方法声明的元类。<br>如：UIView的类方法<br><code>(void)setAnimationsEnabled:(BOOL)enabled;</code><br>就是在UIView的元类中声明的。（见demo）<br>我们知道获取对象的isa指针对象可以调用</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Class</span> object_getClass(id obj)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj) <span class="keyword">return</span> obj-&gt;isa;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> nli;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法，那么上面我们说了将类当做对象来看待的话传<code>object_getClass()</code>方法，返回的就是该类的元类；而<code>object_getClass()</code>接收的是一个id对象，我们可以通过<code>objc_getClass()</code>方法将类名传进去，返回的就是名称对应类。<br>其实还有一个方法<code>objc_getMetaClass()</code>，如下：</p>
<figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">id objc_getMetaClass(<span class="keyword">const</span> char *aClassName)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">Class</span> <span class="title">cls</span>;</span></span><br><span class="line">        <span class="keyword">if</span> (!aClassName) <span class="keyword">return</span> Nli;</span><br><span class="line">        cls = (<span class="class"><span class="keyword">Class</span>)<span class="title">objc_getClass</span> (<span class="title">aClassName</span>);</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> (id)cls-&gt;isa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>观察<code>objc_getMetaClass()</code>的实现，以下两个函数返回的内容是相同的。<br><code>object_getClass(objc_getClass(“UIView”))</code><br><code>objc_getMetaClass(“UIView”)</code><br>类的元类我们获取到了，那么要获取元类的元类也是一样的道理。<br>上面我们提到了<code>objc_getClass()</code>函数，我们发现该方法仅仅通过一个类名称的字符串就可以获取到该名称对应的类结构，观察<code>objc_getClass()</code>函数的实现可以看出，苹果官方framework中提供的所有类都是以key-value的形式在内存中存在的。key代表类名称的字符串，对应的value则代表对应的类结构。 </p>
<h3 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h3><p>怎么做才能够将对象的确定、消息的发送推迟到运行时去处理呢<br><code>objc_msgSend</code>等方法就是解决该问题的核心<br><code>id objc_msgSend(id self, SEL op, …)；</code><br>我们知道oc的编译器在编译的时候将oc格式的函数调用即：<br><code>[target sendMessage:var]；</code><br>转换为c语言函数的调用形式即：<br><code>objc_msgSend(target, @selector(sendMessage), var)；</code><br>如此一来只要<code>objc_msgSend</code>函数存在就能够通过编译链接，在编译的时候编译器不会去检查<code>objc_msgSend</code>函数的参数target和sendMessage到底是什么关系，<strong>而target和sendMessage的关系以及他们之间发生了什么是在去执行<code>objc_msgSend</code>函数的时候(即运行时)才能够真正的去确定的</strong>，这样就巧妙地做到了将对象的确定、消息的发送推迟到运行时去处理。所以所谓的动态特性，就是在静态C语言基础上，维护了一套能够动态的运行时系统，该系统能够对该系统中封装的类进行一些操作。<br>至于<code>objc_msgSend</code>函数的具体实现苹果是没有公开的。 </p>
<h3 id="Method-SEL-and-IMP"><a href="#Method-SEL-and-IMP" class="headerlink" title="Method SEL and IMP"></a>Method SEL and IMP</h3><h4 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h4><p>代表真正存在的代码总称。<br>如:<code>- (int)meaning { return 42; }</code> </p>
<h4 id="Selecter"><a href="#Selecter" class="headerlink" title="Selecter"></a>Selecter</h4><p>即<code>SEL</code>，又名方法选择器，实际上它仅仅是一个指向 <code>char</code>类型的指针(char *)，在 <em>objc.h</em> 中的定义为:<br><code>typedef struct objc_selector *SEL;</code><br>如：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SEL selector = <span class="keyword">@selector</span>(message);<span class="comment">//@selector 不是函数调用,只是编译器能够明白的一个标示</span></span><br><span class="line"><span class="built_in">NSLog</span> (<span class="string">@"%s"</span>, (<span class="keyword">char</span> *)selector);  <span class="comment">//结果输出 message 字符串</span></span><br></pre></td></tr></table></figure>

<p>Objective-C 在编译的时候，会根据方法的名字，生成一个用来区分这个方法的唯一的一个<code>ID</code>，这个<code>ID</code>就是<code>SEL</code>类型的。我们需要注意的是，只要方法的名字相同,那么它们的<code>ID</code>都是相同的。而这也就导致了 Objective-C 在处理有相同函数名和参数个数但参数类型不同的函数时会出现编译错误，比如：当你想在同一个类中实现下面两个方法: </p>
 <figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)setWidth:(<span class="keyword">int</span>)<span class="built_in">width</span>;</span><br><span class="line">-(<span class="keyword">void</span>)setWidth:(<span class="keyword">double</span>)<span class="built_in">width</span>;</span><br></pre></td></tr></table></figure>

<p>而在 C++中对于函数名相同参数个数相同但是参数类型不同的函数是可以在同一类中定义的， 编译的时候编译器会将函数转换为类似<code>setWidth_int</code>和<code>setWidth_double</code>从而进行区分。 </p>
<h4 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a>IMP</h4><p>IMP 在 objc.h 中的定义为:  </p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef id (*<span class="type">IMP</span>)(id, <span class="type">SEL</span>, …);</span><br></pre></td></tr></table></figure>

<p>熟悉 C 语言的同学应该清楚 IMP 实际上就以一个指向函数的指针。<br>上面我们提到过每一个类中都保存了指向父类的指针和一个方法列表（当然还有其他的属性），你可以将这个方法列表理解为一个有键值关系的数据模型(hash表或字典)，<code>key</code>为<code>SEL</code>指向的字符串，<code>value</code>为<code>IMP</code>。 在方法列表中<code>SEL</code>与<code>IMP</code>形成了一种一一对应的唯一映射关系。由于每个方法都对应唯一的SEL(同一个类中不能出现名称相同的函数即使它们有不同类型的参数)，因此我们可以通过<code>SEL</code>方便、快速、准确的获得它所对应的IMP(也就是函数指针)，而在取得了函数指针之后，也就意味着我们取得了执行的时候的这段方法的代码的入口，这样我们就可以像普通的C语言函数调用一样使用这个函数指针。当然我们可以把函数指针作为参数传递到其他的方法，或者实例变量里面，从而获得极大的动态性。<strong>很重要的一点是：selector 和 IMP 之间的关系是在运行时才决定的，而不是编译时</strong>。 下面的例子，介绍了取得函数指针，即函数指针的用法: </p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void <span class="comment">(* performMessage)(id,SEL);//定义一个 IMP(函数指针)</span></span><br><span class="line"><span class="comment">performMessage = (void (*)</span>(id,SEL))[<span class="keyword">self</span> methodForSelector:@<span class="keyword">selector</span>(message)]; <span class="comment">//通过 methodForSelector 方法根据 SEL 获取对应的函数指针 </span></span><br><span class="line">performMessage(<span class="keyword">self</span>,@<span class="keyword">selector</span>(message));<span class="comment">//通过取到的 IMP(函数指针)跳过 runtime 消息分发机制，直接执行 message 方法</span></span><br></pre></td></tr></table></figure>

<p>需要指出的是：用<code>IMP</code>的方式，省去了runtime消息分发过程中所做的一系列动作，比直接向对象发送消息高效一些。(见示例项目)  </p>
<h3 id="消息的分发"><a href="#消息的分发" class="headerlink" title="消息的分发"></a>消息的分发</h3><h4 id="消息分发流程"><a href="#消息分发流程" class="headerlink" title="消息分发流程"></a>消息分发流程</h4><p>一切还是从消息表达式 <code>[receiver message]</code> 开始，在被转换成 <code>objc_msgSend(receiver, SEL)</code> 后，在运行时，runtime system 会做以下事情: </p>
<ul>
<li>检查忽略的 Selector,比如当我们运行在有垃圾回收机制的环境中，将会忽略 retain 和 release 消息。</li>
<li>检查 receiver 是否为 nli。不像其他语言,nli 在 objective-C 中是完全合法的，并且这里有<br>很多原因你也愿意这样，比如，至少我们省去了给一个对象发送消息前检查对象是否为空的操作。如 果 receiver 为空，则会将 selector 也设置为空,并且直接返回到消息调用的地方。如果对象非空，就继续下一步。<br>*接下来会根据 SEL 到当前类中查找对应的 IMP，首先会在 cache 中检索它，如果找到了就根据函数指针跳转到这个函数执行，否则进行下一步。 </li>
<li>检索当前类对象中的方法表(dispathch table)，如果找到了，加入 cache 中，并且就跳转到这个函数之行,否则进行下一步。 </li>
<li>从父类中寻找,直到根类：NSObject 类。找到了就将方法加入对应类的 cache 表中；如果仍未找到，则要进入<strong>动态方法决议(resolveInstanceMethod)</strong>。</li>
<li>如果动态方法决议仍不能解决问题，只能进行最后一次尝试，进入<strong>消息转发流程 (forwardingTargetForSelector)</strong>。</li>
<li>如果还不行，崩溃……</li>
</ul>
<p>下面的图部分展示了这个调用过程  </p>
<img src="/2014-11-18-141118-oc-runtime-feature/141118-oc-runtime-feature-01.png" title="消息查找流程">

<h4 id="函数检索优化措施"><a href="#函数检索优化措施" class="headerlink" title="函数检索优化措施"></a>函数检索优化措施</h4><ul>
<li>通过SEL进行IMP匹配编译器根据每个方法的名称为那个方法生成一个唯一的<code>selector</code>，而<code>selector</code>的唯一性，能确保查找方法时提高一部分的效率。 </li>
<li>cache缓存<br>cache的原则就是缓存那些可能要执行的函数地址，那么下次调用的时候,速度就可以快速很多。这个和CPU的各种缓存原理相通。<code>objc_msgSend</code>首先在 cache list 中找 SEL，没有找到就 在 class method 中找，super class method 中找(当然 super class 也有 cache list)。而 cache 的机制则非常复杂了，由于 Objective-C 是动态语言。所以，这里面还有很多的多线程同步问题，而这些锁又是效率的大敌,相关的内容已经远远超过本文讨论的范围。<br>如果在缓存中已经有了需要的方法选标，则消息仅仅比函数调用慢一点点。如果程序运行了足够长的时间，几乎每个消息都能在缓存中找到方法实现。程序运行时，缓存也将随着新的消息的增加而增加。据测试，苹果通过这些优化，使消息分发和直接的函数调用效率上的差距已经 相当的小。 </li>
</ul>
<h3 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h3><h4 id="方法重定向"><a href="#方法重定向" class="headerlink" title="方法重定向"></a>方法重定向</h4><ul>
<li><p>动态添加方法<br>有时，你只想在运行时才创建某个方法，比如有些信息只有在运行时才能得到。要实现这个效果，你需要重写<br><code>+resolveInstanceMethod:</code> 和/或 <code>+resolveClassMethod:</code>。<br>如果确实增加了一个方法,记得返回 YES。</p>
<figure class="highlight plain"><figcaption><span>(BOOL)resolveInstanceMethod:(SEL)aSelector &#123; </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">	if (aSelector == @selector(myDynamicMethod)) &#123; </span><br><span class="line">		class_addMethod(self, aSelector, (IMP)myDynamicIMP, &quot;v@:&quot;); </span><br><span class="line">		return YES; </span><br><span class="line">	&#125; </span><br><span class="line">	return [super resolveInstanceMethod:aSelector]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法的重定向Objective-C 2.0 提供了@dynamic 关键字,它的作用为:<br>a.告诉编译器不要创建实现属性所用的实例变量<br>b.告诉编译器不要创建属性的 get 和 setter 方法 如果我们在@interface 接口文件中声明了一个属性，如下所示:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">retain</span>) <span class="built_in">NSString</span> *name;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>默认情况下，编译器会为当前类自动生成一个<code>NSString *_name</code>的实例变量（如果想改变实例变量的名称可以用@synthesize 关键字），同时会生成两个名为：</p>
 <figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(NSString *)</span>name <span class="params">(void)</span></span><br><span class="line">- setName:<span class="params">(NSString *)</span>aName</span><br></pre></td></tr></table></figure>

<p>的存取方法。<br>而@dynamic关键字就是告诉编译器不要做这些事，同时在使用了存取方法时也不要报错，即让编译器相信存取方法会在运行时找到。比如在@implementation 文件中做了如下声明:</p>
 <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">dynamic</span> name;</span><br></pre></td></tr></table></figure>

<p>如果使用了 name 属性的 setter 方法，又不想在运行时崩溃，就可以进行一下操作:</p>
 <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> dynamicMethodIMP(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd)&#123; </span><br><span class="line"><span class="comment">// implementation .... </span></span><br><span class="line">&#125; </span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123; </span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@"sel is %@"</span>, <span class="built_in">NSStringFromSelector</span>(sel)); </span><br><span class="line">	<span class="keyword">if</span>(sel == <span class="keyword">@selector</span>(name))&#123; </span><br><span class="line">		class_addMethod([<span class="keyword">self</span> <span class="keyword">class</span>],sel,(IMP)dynamicMethodIMP,<span class="string">"v@:"</span>); </span><br><span class="line">		<span class="keyword">return</span> <span class="literal">YES</span>; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>resolveInstanceMethod</code>的实现中，我们通过 <code>class_addMethod</code>方法动态的向当前对象增加了 <code>dynamicMethodIMP</code>函数，来代替</p>
 <figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>setName:<span class="params">(NSString *)</span>name</span><br></pre></td></tr></table></figure>

<p>的实现部分，从而 达到了动态生成 name 属性方法的目的。<br>值得说明的是: </p>
<p> <strong>a.</strong> 在上个例子中，我们自己实现了<code>set</code>方法，则在运行的时候，调用完我们实现的<code>set</code>方法后，运行时系统仍然会调 </p>
 <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">BOOL) </span>resolveInstanceMethod:(<span class="keyword">SEL) </span><span class="keyword">sel</span></span><br></pre></td></tr></table></figure>

<p>方法，只不过这里的<code>sel</code>会变成<code>_doZombieMe</code>，从而我们实现重定向的<code>if</code>分支就进不去了，即我们实现的方法不会被覆盖。</p>
<p> <strong>b.</strong> “v@:”属于 Objective-C 类型编码的内容,感兴趣的同学可以自己 google 一下。<br>注意：resolveInstanceMethod:是 NSObject 根类提供的类方法，<strong>调用时机为被调用的方法实现部分没有找，而消息转发机制启动之前的这个中间时刻</strong>。</p>
<h4 id="消息转发机制"><a href="#消息转发机制" class="headerlink" title="消息转发机制"></a>消息转发机制</h4><p>当对象无法响应发送给他的消息时怎么办?<br>runtime 提供了消息转发机制来处理该问题。 当外部调用的某个方法对象没有实现,而且 <code>resolveInstanceMethod</code> 方法中也没有做重定向处理时，就会触发</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(id)</span>forwardingTargetForSelector:<span class="params">(SEL)</span>aSelector</span><br></pre></td></tr></table></figure>

<p>方法。在该方法中你可以去将不能响应的消息转发给其他的 target，返回值就是该 target 的值，即最终 aSelector 将会被转发给返回的 target。代码如下:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector&#123; </span><br><span class="line">	<span class="keyword">if</span> (aSelector == <span class="meta">@selector(uppercaseString)</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> @<span class="string">"Hello"</span>; </span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> nli; </span><br><span class="line">	&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="对象、类的操作函数"><a href="#对象、类的操作函数" class="headerlink" title="对象、类的操作函数"></a>对象、类的操作函数</h3><p>如果像静态语言一样对象属性及方法在编译的时候就已经确定了，那么在此基础上再维护一个运行时系统就显得多此一举了，因此在OC中对象的类型及其属性，方法，协议等内容到运行时才能确定，说明在运行时之前你可以对对象的属性，方法，协议等进行“编辑”，所谓“编辑”就包括“增删改查”等操作。那么我们来看一下OC都提供了那些方法是我们能够对对象的哪些属性进行什么样的修改：<br>针对class的操作函数如：<br><code>class_addIvar</code><br><code>class_addMethod</code><br><code>class_addProperty</code><br><code>class_addProtocol</code> 允许对class进行动态修改<br><code>class_copyIvarList</code><br><code>class_copyMethodList</code><br><code>class_copyProtocolList</code><br><code>class_copyPropertyList</code>能拿到一个class的变量、方法、协议及属性列表<br><code>class_getClassMethod</code><br><code>class_getClassVariable</code><br><code>class_getInstanceMethod</code><br><code>class_getInstanceVariable</code><br><code>class_getMethodImplementation</code><br><code>class_getProperty</code>获取class的单个方法、属性、变量等<br>也有一些通用的自省方法,如<br><code>class_conformsToProtocol</code><br><code>class_respondsToSelector</code><br><code>class_getSuperclass</code><br>你甚至可以使用<code>class_createInstance</code>来创建一个类的实例</p>
<p>针对object的操作函数如：<br>你可以 get/set ivar, 使用 <code>object_copy</code> 和 <code>object_dispose</code> 来 copy 和 free object 的内存。而且不仅是拿到一个 class，而是可以使用 <code>object_setClass</code> 来改变一个 object 的 class。<br>针对method的操作函数如：<br>主要用来自省的方法：<br><code>method_getName</code><br><code>method_getImplementation</code><br><code>method_getReturnType</code> 等等。<br>也有一些修改的方法,包括<br><code>method_setImplementation</code><br><code>method_exchangeImplementations</code>。 </p>
<p>针对property的操作函数如：<br>property属性保存了很大一部分信息。除了拿到名字,你还可以使用 <code>property_getAttributes</code> 来发现 property 的更多信息,如返回值、是否为 atomic、getter/setter 名字、是否为 dynamic、背后使用的 ivar 名字、是否为弱引用。  </p>
<p>其他还包括针对protocol，selelctor的方法，这里就不一一列举。 </p>
<h3 id="Refrence"><a href="#Refrence" class="headerlink" title="Refrence"></a>Refrence</h3><p><a href="http://limboy.me/ios/2013/08/03/dynamic-tips-and-tricks-with-objective-c.html" target="_blank" rel="noopener">Objective-C的动态特性</a><br><a href="http://alexliyu.blog.163.com/blog/static/162754496201252115612810/" target="_blank" rel="noopener">深刻理解Python中的元类</a><br><a href="http://www.cocoawithlove.com/2010/01/what-is-meta-class-in-objective-c.html" target="_blank" rel="noopener">What is meta class in Objective-C</a><br><a href="http://blog.csdn.net/wzzvictory/article/details/8615569" target="_blank" rel="noopener">Objective-C runtime之运行时的基本特点</a></p>

    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
              <a href="/2011-09-30-110930-thinking-of-freedom.html" rel="next" title="自由">
                <i class="fa fa-chevron-left"></i> 自由
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
              <a href="/2015-05-07-150507-ios-screen-rotate.html" rel="prev" title="iOS屏幕旋转的回调过程">
                iOS屏幕旋转的回调过程 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
    </footer>
  </div>
  
  
  
  </article>

  </div>


          </div>
          


        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/avatar.png"
      alt="Zrongl">
  <p class="site-author-name" itemprop="name">Zrongl</p>
  <div class="site-description motion-element" itemprop="description"></div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        
        
          
        
          
        
          
        
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
  </nav>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/zrongl" title="GitHub &rarr; https://github.com/zrongl" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="mailto:ronglei0324@163.com" title="E-Mail &rarr; mailto:ronglei0324@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
    
  </div>



        </div>
      </div>
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#C语言编译链接过程"><span class="nav-number">1.</span> <span class="nav-text">C语言编译链接过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象，类及元类的关系："><span class="nav-number">2.</span> <span class="nav-text">对象，类及元类的关系：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#消息"><span class="nav-number">3.</span> <span class="nav-text">消息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Method-SEL-and-IMP"><span class="nav-number">4.</span> <span class="nav-text">Method SEL and IMP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Method"><span class="nav-number">4.1.</span> <span class="nav-text">Method</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Selecter"><span class="nav-number">4.2.</span> <span class="nav-text">Selecter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IMP"><span class="nav-number">4.3.</span> <span class="nav-text">IMP</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#消息的分发"><span class="nav-number">5.</span> <span class="nav-text">消息的分发</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#消息分发流程"><span class="nav-number">5.1.</span> <span class="nav-text">消息分发流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数检索优化措施"><span class="nav-number">5.2.</span> <span class="nav-text">函数检索优化措施</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态方法解析"><span class="nav-number">6.</span> <span class="nav-text">动态方法解析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#方法重定向"><span class="nav-number">6.1.</span> <span class="nav-text">方法重定向</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#消息转发机制"><span class="nav-number">6.2.</span> <span class="nav-text">消息转发机制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象、类的操作函数"><span class="nav-number">7.</span> <span class="nav-text">对象、类的操作函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Refrence"><span class="nav-number">8.</span> <span class="nav-text">Refrence</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zrongl</span>
</div>
<div class="powered-by">
<i class="fa fa-user-md"></i>
<span>不争无尤</span>
</span>
</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.3.0</div>

        








        
      </div>
    </footer>
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>

    

  </div>

  
    
    
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest-nomobile.min.js"></script>
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

<script src="/js/utils.js?v=7.3.0"></script>
  <script src="/js/motion.js?v=7.3.0"></script>


  <script src="/js/schemes/muse.js?v=7.3.0"></script>



<script src="/js/next-boot.js?v=7.3.0"></script>






  




























  

  

  

  


  
  <script src="/js/scrollspy.js?v=7.3.0"></script>
<script src="/js/post-details.js?v=7.3.0"></script>


  <!-- 页面点击小红心 -->
  <script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
